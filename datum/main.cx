//code generated by CXDatum. DO NOT EDIT.


package main

import "model"

func extractThing(sl []ui8) (out []ui8) {
    for i := 1; i < len(sl); i++ {
        out = append(out, sl[i])
    }
}

func main()() {
    model.initdb()

    /* the following is generated by CXDatum. */
    %s

    var success bool
    success = cxdatum.launch()
    if !success {
        printf("abort - chain couldn't even launch\n")
        return
    }
    printf("[CXDATUM] launched blockchain.\n")
    /* get length */
    var lentidx i32 = 0
    var lent    i32
    var lentser []ui8
    var synclen i32
    var lentstr str
    lentstr = "meta"
    var yghs []ui8
    yghs = cxdatum.str2bytes("meta")
    lentser = cxdatum.fetch(model.dbmeta, yghs)
    if len(lentser) > 0 {
        lent = model.deserializeI32(lentser, &lentidx)
        printf("[CXDATUM] length retrieved from meta database.\n")
    } else {
        lent = 1
        printf("[CXDATUM] starting new length.\n")
    }
    synclen = cxdatum.chainlen()
    printf("[CXDATUM] got chain length from API: %d\n", synclen)
    if synclen == -1 {
        printf("abort - chain length invalid!\n")
        return
    }
    /* make account */
    var mksucc bool
    mksucc = cxdatum.mkaccount()
    if !mksucc {
        printf("abort - account failure\n")
        return
    }
    printf("[CXDATUM] account created. Grabbing blocks.\n")
    /* now we grab all the blocks in the world */
    var block []ui8
    for i := lent; i <= synclen; i++ {
	    if i < 1 {
		    printf("[CXDATUM] SKIPPING BLOCK %d.\n", i)
	    } else {
        	block = cxdatum.getblock(i)
        	model.ProcessIncoming(i, block)
        	printf("[CXDATUM] block %d processed successfully.\n", i)
	    }
    }
    lent = synclen
    /* launch the api */
    var ok bool
    ok = cxdatum.launchapi()
    if !ok {
        printf("api launch failed!")
        return
    }
    printf("[CXDATUM] API successfully launched.\n")
    /* everything should be processed, so it's time to do the loop */
	var CXDATUM_EGRESS_CODE_getTweet ui8 = 0
	for i := 0; i < 1000000000; i++ {
		var outgoing []ui8
		var incoming []ui8
		incoming = cxdatum.stall()
		var _cxdatum_tmp_133 []ui8
		_cxdatum_tmp_133 = extractThing(incoming)
		var idx ui8 = incoming[0]
		if idx == CXDATUM_EGRESS_CODE_getTweet {
			var _cxdatum_tmp_134 getTweet_arg_EgressExpect
			_cxdatum_tmp_134 = deserializegetTweet_arg_EgressExpect(_cxdatum_tmp_133)
			var _cxdatum_tmp_135 [32]ui8
			_cxdatum_tmp_135 = _cxdatum_tmp_134.txid
			outgoing = model.getTweet(_cxdatum_tmp_135)
		} else {
        printf("abort - unknown code!\n")
        return
    }
    nlent = cxdatum.chainlen()
    if nlent > lent {
        printf("[CXDATUM] new block(s) received (new length: %d), (old: %d)\n", nlent, lent)
        lent = lent + 1
        for i := lent; i <= nlent; i++ {
            block = cxdatum.getblock(i)
            model.ProcessIncoming(i, block)
            printf("[CXDATUM] block %d processed successfully.\n", i)
        }
    }
    lent = nlent
    var nlentser [4]ui8
    nlentser = model.serializeI32(lent)
    var nlenser []ui8
    for y := 0; y < 4; y++ {
        nlenser = append(nlenser, nlentser[y])
    }
    var nlentserok bool
    var tmpstr2 []ui8
    tmpstr2 = cxdatum.str2bytes("meta")
    nlentserok = cxdatum.store(model.dbmeta, tmpstr2, nlenser)
    if nlentserok {
        printf("[CXDATUM] meta database successfully updated.\n")
    } else {
        printf("[CXDATUM] meta database error: cannot write!\n")
    }
    cxdatum.expose(outgoing)
    printf("[CXDATUM] cycle has been completed.\n")
}
}


