package syntax

import (
	"fmt"
	"io/ioutil"
	"os"
	"strconv"
	"strings"
	"time"
)

func CompileFile(fn string) {
	c := Compiler{}
	c.Init(fn)
	c.parse()
	c.gensymp = "_cxdatum_tmp_"
	c.cxmodel += stdcxmodel
	c.gomodel += stdgomodel
	for _, v := range c.data {
		c.compileDatum(v)
	}
	c.compileDatabases()
	/* for main */
	if c.main == nil {
		panic("missing main!")
	}
	c.main.name = "ProcessIncoming"
	for _, v := range c.igrs {
		c.compileIngress(v)
	}
	/* argh. egress. */
	for _, v := range c.egrs {
		c.compileEgress(v)
	}
	c.compileMain()
	/* model.cx is cxmodel + cxser + cxdser */
	/* process.cx is cxdbase + stdcxops + cxigrs + cxegrs */
	/* main.cx is cxmain */
	/* model.go is gomodel + goser + godser */
	/* process.go is goegrs + (user code) */
	modeldotcx := "//code generated by CXDatum. DO NOT EDIT.\n\n" + c.cxmodel + "\n\n" + c.cxser + "\n\n" + c.cxdser + "\n"
	processdotcx := "//code generated by CXDatum. DO NOT EDIT.\n\n" + c.cxdbase + "\n\n" + stdcxops + "\n\n" + c.cxigrs + "\n\n" + c.cxegrs + "\n"
	maindotcx := "//code generated by CXDatum. DO NOT EDIT.\n\n" + c.cxmain + "\n"
	modeldotgo := "//code generated by CXDatum. DO NOT EDIT.\n\n" + c.gomodel + "\n\n" + c.goser + "\n\n" + c.godser + "\n"
	processdotgo := "//code generated by CXDatum. DO NOT EDIT.\n\n" + c.goegrs + "\n"
	//cxtotal := "//code generated by CXDatum. DO NOT EDIT.\n\n" + c.cxmodel + "\n\n\n" + c.cxser + "\n\n\n" + c.cxdser + "\n\n\n" + c.cxigrs + "\n\n\n" + c.cxegrs + "\n\n\n" + c.cxmain
	//fmt.Printf("\n=================================\n\n\n%s\n\n\n============================\n%s\n\n\n%s\n\n\n%s\n", cxtotal, c.gomodel, c.goser, c.godser)
	/* write files. puts cx files in a folder called datum, and go code in a folder called model. */
	//os.RemoveAll("datum")
	//os.RemoveAll("model")
	os.Remove("datum/model.cx")
	os.Remove("datum/process.cx")
	os.Remove("datum/main.cx")
	os.Remove("model/model.go")
	os.Remove("model/process.go")
	os.Mkdir("datum", 0777)
	os.Mkdir("model", 0777)
	/* sleep in between to allow FS to update. */
	time.Sleep(time.Millisecond * 10)
	ioutil.WriteFile("datum/model.cx", []byte(modeldotcx), 0644)
	ioutil.WriteFile("datum/process.cx", []byte(processdotcx), 0644)
	ioutil.WriteFile("datum/main.cx", []byte(maindotcx), 0644)
	ioutil.WriteFile("model/model.go", []byte(modeldotgo), 0644)
	ioutil.WriteFile("model/process.go", []byte(processdotgo), 0644)
}

type Compiler struct {
	Parser

	//datum structs
	cxmodel string //model code
	gomodel string //model code

	//datum serialization
	cxser string
	goser string

	//datum deserialization
	cxdser string
	godser string

	//database
	cxdbase string

	//ingress code
	cxigrs string

	//egress code
	cxegrs string
	goegrs string

	//cx main
	cxmain string

	//symbol generation
	gensymp string
	gensymc uint
}

var backstack []string //a stack for storing backgen'd code for updates.

var stdcxops string = `
func isBase58(code ui8) (out bool) {
    out = false
    var magicstr []ui8
    magicstr = cxdatum.str2bytes("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz")
    for i := 0; i < len(magicstr); i++ {
        if code == magicstr[i] {
            out = true
            return
        }
    }
}

func isTweetHashtag(code ui8) (out bool) {
    out = false
    var magicstr []ui8
    magicstr = cxdatum.str2bytes("0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz_")
    for i := 0; i < len(magicstr); i++ {
        if code == magicstr[i] {
            out = true
            return
        }
    }
}

func toHexDigit(code ui8) (out ui8) {
    if code < 64UB {
        out = code - 48UB
    } else {
        out = code - 87UB
    }
}

func shaToHex(sha [32]ui8) (out str) {
    var arr []ui8
    var idx i32
    var intmp ui8
    for i := 0; i < 32; i++ {
        intmp = sha[i]
        intmp = intmp / 16UB
        intmp = intmp + 48UB
        if intmp >= 58UB {
            intmp = intmp + 39UB
        }
        arr = append(arr, intmp)

        intmp = sha[i]
        intmp = intmp % 16UB
        intmp = intmp + 48UB
        if intmp >= 58UB {
            intmp = intmp + 39UB
        }
        arr = append(arr, intmp)
    }

    out = cxdatum.bytes2str(arr)
}


func stringToSha(s str) (out [32]ui8) {
    var tpcode ui8
    var indx i32 
    var tweet []ui8
    tweet = cxdatum.str2bytes(s)
    if len(tweet) != 64 {
        out = cxdatum.sumsha256(tweet)
        return
    }
    for i := 0; i < 32; i++ {
        tpcode = toHexDigit(tweet[indx])
        indx = indx + 1
        tpcode = tpcode * 16UB
        tpcode = tpcode + toHexDigit(tweet[indx])
        indx = indx + 1
        out[i] = tpcode
    }
}
`

var stdgomodel string = `
package model

import (
    "github.com/SkycoinProject/skycoin/src/cipher"
)

func makeInt(b []byte) int {
	return (int(b[0]) << 24) | (int(b[1]) << 16) | (int(b[2]) << 8) | int(b[3])
}

func breakInt(i int) []byte {
	b := make([]byte, 4)
	b[0] = byte((i & 0xFF000000) >> 24)
	b[1] = byte((i & 0xFF0000) >> 16)
	b[2] = byte((i & 0xFF00) >> 8)
	b[3] = byte(i & 0xFF)
	return b
}
`

//the standard cx model code
var stdcxmodel string = `
package model

import "cxdatum"

func deserializeI32(sl []ui8, idx_ *i32) (out i32) {
    var idx i32 = *idx_
    out = i32.bitshl(ui8.i32(sl[idx]), 24)
    out = i32.bitor(out, i32.bitshl(ui8.i32(sl[i32.add(idx, 1)]), 16))
    out = i32.bitor(out, i32.bitshl(ui8.i32(sl[i32.add(idx, 2)]), 8))
    out = i32.bitor(out, ui8.i32(sl[i32.add(idx, 3)]))
    (*idx_) = i32.add(idx, 4)
}

func deserializeStr(sl []ui8, idx_ *i32) (out str) {
    var idx i32 = *idx_
	var slen i32
	if len(sl) <= idx {
		return
	}
	slen = deserializeI32(sl, &idx)
    var strb []ui8 
    for i := 0; i < slen; i++ {
        strb = append(strb, sl[idx + i])
    }
	out = cxdatum.bytes2str(strb)
    (*idx_) = idx + slen
}

func deserializeStrSlice(sl []ui8, idx_ *i32) (out []str) {
    var idx i32 = *idx_
    var slen i32
	var strt str
	if len(sl) <= idx {
		return
	}
    slen = deserializeI32(sl, &idx)
    for j := 0; j < slen; j++ {
        strt = deserializeStr(sl, &idx)
        out = append(out, strt)
    }
    (*idx_) = idx
}

func deserializeWalSlice(sl []ui8, idx_ *i32) (out []ui8) {
    var idx i32 = *idx_
	var slen i32
	if len(sl) <= idx {
		return
	}
    slen = deserializeI32(sl, &idx)
    var slenn i32
    slenn = slen*25
    for j := 0; j < slenn; j++ {
        out = append(out, sl[j+idx])
    }
    
    idx = idx + slenn
    (*idx_) = idx
}

func deserializeShaSlice(sl []ui8, idx_ *i32) (out []ui8) {
    var idx i32 = *idx_
	var slen i32
	if len(sl) <= idx {
		return
	}
    slen = deserializeI32(sl, &idx)
    var slenn i32
    slenn = slen*32
    for j := 0; j < slenn; j++ {
        out = append(out, sl[j+idx])
    }
    (*idx_) = i32.add(idx, slenn)
}

func deserializeWal(sl []ui8, idx_ *i32) (out [25]ui8) {
	var idx i32 = *idx_
	var tmtst i32
	tmtst = idx + 25
	if len(sl) < tmtst {
		return
	}
    for i := 0; i < 25; i++ {
        out[i] = sl[i32.add(idx, i)]
    }
    (*idx_) = i32.add(idx, 25)
}

func deserializeSha(sl []ui8, idx_ *i32) (out [32]ui8) {
	if len(sl) < 32 {
		return
	}
	var idx i32 = *idx_
	var tmtst i32
	tmtst = idx + 32
	if len(sl) < tmtst {
		return
	}
    for i := 0; i < 32; i++ {
        out[i] = sl[i32.add(idx, i)]
    }
    (*idx_) = i32.add(idx, 32)
}

func serializeI32(i i32) (out [4]ui8) {
    i0 := i32.ui8(i32.bitshr(i, 24))
    i1 := i32.ui8(i32.bitshr(i32.bitand(16711680, i), 16))
    i2 := i32.ui8(i32.bitshr(i32.bitand(65280, i), 8))
    i3 := i32.ui8(i32.bitand(255, i))
    out = [4]ui8{i0, i1, i2, i3}
}

func serializeWalSlice(sl []ui8) (out []ui8) {
    var len_ i32
    len_ = len(sl)
    len_ = i32.div(len_, 25)
    var slen [4]ui8 
    slen = serializeI32(len_)
    for i := 0; i < 4; i++ {
        out = append(out, slen[i])
    }
    for j := 0; j < len(sl); j++ {
        out = append(out, sl[j])
    }
}

func serializeWal(sl [25]ui8) (out []ui8) {
    for i := 0; i < 25; i++ {
        out = append(out, sl[i])
    }
}

func serializeSha(sl [32]ui8) (out []ui8) {
    for i := 0; i < 32; i++ {
        out = append(out, sl[i])
    }
}

func serializeShaSlice(sl []ui8) (out []ui8) {
    var len_ i32
    len_ = len(sl) 
    len_ = i32.bitshr(len_, 5)
    var slen [4]ui8 
    slen = serializeI32(len_)
    for i := 0; i < 4; i++ {
        out = append(out, slen[i])
    }
    for j := 0; j < len(sl); j++ {
        out = append(out, sl[j])
    }
}

func serializeStr(s str) (out []ui8) {
    var serstr []ui8 
    serstr = cxdatum.str2bytes(s)
    var serlen [4]ui8 = serializeI32(len(serstr))
    for i := 0; i < 4; i++ {
        out = append(out, serlen[i])
    }
    for i := 0; i < len(serstr); i++ {
        out = append(out, serstr[i])
    }
}

func serializeStrSlice(sl []str) (out []ui8) {
    var slen [4]ui8 = serializeI32(len(sl))
    for i := 0; i < 4; i++ {
        out = append(out, slen[i])
    }
    for j := 0; j < len(sl); j++ {
        var serstr []ui8 = serializeStr(sl[j])
        for i := 0; i < len(serstr); i++ {
            out = append(out, serstr[i])
        }
    }
}

func walSliceAppend(wsl []ui8, wal [25]ui8) (out []ui8) {
    for i := 0; i < 25; i++ {
        wsl = append(wsl, wal[i])
    }
    out = wsl
}

func shaSliceAppend(ssl []ui8, sha [32]ui8) (out []ui8) {
    for i := 0; i < 32; i++ {
        ssl = append(ssl, sha[i])
    }
    out = ssl
}

func shaSliceIndex(ssl []ui8, idx i32) (out [32]ui8) {
    var cidx i32
    for i := 0; i < 32; i++ {
        cidx = 32 * idx + i
        out[i] = ssl[cidx]
    }
}

func walSliceIndex(wsl []ui8, idx i32) (out [25]ui8) {
    var cidx i32
    for i := 0; i < 25; i++ {
        cidx = 25 * idx + i
        out[i] = wsl[cidx]
    }
}

func serializeI32Slice(sl []i32) (out []ui8) {
	var slen [4]ui8 = serializeI32(len(sl))
    for i := 0; i < 4; i++ {
        out = append(out, slen[i])
    }
    for j := 0; j < len(sl); j++ {
        var sernum [4]ui8 = serializeI32(sl[j])
        for i := 0; i < 4; i++ {
            out = append(out, sernum[i])
        }
    }
}

func deserializeI32Slice(sl []ui8, idx_ *i32) (out []i32) {
	var idx i32 = *idx_
	var slen i32
	if len(sl) <= idx {
		return
	}
    slen = deserializeI32(sl, &idx)
    for j := 0; j < slen; j++ {
		var snum i32
		snum = deserializeI32(sl, &idx)
		out = append(out, snum)
	}
    (*idx_) = idx
}
`

func (c *Compiler) compileIngress(d *DGlause) {
	/* ingress specifies a function that can be called by CX for processing. ingress functions allow mutability. */
	incnt := 1
	rv := fmt.Sprintf("func %s (", d.name)
	for i, _ := range d.expt {
		rv += d.expt[i].name + " " + compileType(d.expt[i].typ, true)
		if i < len(d.expt)-1 {
			rv += ", "
		}
	}
	rv += ") {\n"
	/* compiling statements now. Can be one helluva bitch. */
	for i, _ := range d.clauses {
		rv += c.compileClause(incnt, d.clauses[i])
	}
	rv += "}\n\n"
	c.cxigrs += rv
}

func (c *Compiler) compileEgress(d *DGlause) {
	/* egress functions may expect inputs, but must return variable of type []ui8 */
	incnt := 1
	rv := fmt.Sprintf("func %s (", d.name)
	for i, _ := range d.expt {
		rv += d.expt[i].name + " " + compileType(d.expt[i].typ, true)
		if i < len(d.expt)-1 {
			rv += ", "
		}
	}
	rv += ") (out []ui8) {\n"
	for i, _ := range d.ret {
		rv += c.compileVar(1, d.ret[i])
	}
	/* compiling statements now. Can be one helluva bitch. */
	for i, _ := range d.clauses {
		rv += c.compileClause(incnt, d.clauses[i])
	}
	/* we insert the magical thing. */
	retv := c.gensym()
	rv += fmt.Sprintf("\tvar %s %s_arg_EgressReturn\n\t%s = %s_arg_EgressReturn{}\n", retv, d.name, retv, d.name)
	for i, _ := range d.ret {
		rv += fmt.Sprintf("\t%s.%s = %s\n", retv, d.ret[i].name, d.ret[i].name)
	}
	rv += fmt.Sprintf("\tout = serialize%s_arg_EgressReturn(%s)\n", d.name, retv)
	rv += "}\n\n"
	c.cxegrs += rv
}

func (c *Compiler) compileAppend(typ *DType, index bool, arr string, idx string) string {
	/* returns func for indexing or append */
	switch typ.tkind {
	case TKINDBYTE, TKINDSTRING, TKINDINT:
		if index {
			return fmt.Sprintf("%s[%s]", arr, idx)
		} else {
			return fmt.Sprintf("append(%s, %s)", arr, idx)
		}
	case TKINDWALLET:
		if index {
			return fmt.Sprintf("walSliceIndex(%s, %s)", arr, idx)
		} else {
			return fmt.Sprintf("walSliceAppend(%s, %s)", arr, idx)
		}
	case TKINDHASH:
		if index {
			return fmt.Sprintf("shaSliceIndex(%s, %s)", arr, idx)
		} else {
			return fmt.Sprintf("shaSliceAppend(%s, %s)", arr, idx)
		}
	}

	panic("cannot do append or index of this type! : " + dtypeToString(typ))
}

func (c *Compiler) compileClause(incnt int, d *DClause) string {
	rv := ""
	id := strings.Repeat("\t", incnt)
	switch d.ckind {
	case CKINDFOR:
		rv += c.compileFor(incnt, d)
	case CKINDCALL:
		/* actually, pretty simple. */
		args := ""
		for i, _ := range d.exprs {
			rv += c.compileExpr(incnt, d.exprs[i], false)
			args += d.exprs[i].kname
			if i < len(d.exprs)-1 {
				args += ", "
			}
		}
		rv += fmt.Sprintf("%s%s(%s)\n", id, d.igrs.name, args)
	case CKINDDECL:
		/* create var last */
		rv += c.compileExpr(incnt, d.expr, false)
		rv += c.compileVar(incnt, d.nvar)
		rv += fmt.Sprintf("%s%s = %s\n", id, d.nvar.name, d.expr.kname)
	case CKINDUPDATE:
		/* this one is interesting!!!!! */
		rv += c.compileExpr(incnt, d.expr, true)
		/* backprop!!! */
		for i := len(backstack) - 1; i >= 0; i-- {
			rv += backstack[i]
		}
		backstack = []string{} /* eBic. */
	case CKINDEXACT:
		/* write to blockchain! */
		rv += c.compileExpr(incnt, d.expr, false)
		bvar := c.gensym()
		rv += fmt.Sprintf("%svar %s bool\n%s%s = cxdatum.transact(%s)\n", id, bvar, id, bvar, d.expr.kname)
	case CKINDMATCH:
		/* ugh. */
		rv += c.compileExpr(incnt, d.expr, false)
		/* now we need to do thingies. */
		/* the most annoying thing here is needing to do all scls exprs first */
		for i, _ := range d.scls {
			rv += c.compileExpr(incnt, d.scls[i].expr, false)
		}
		for i, _ := range d.scls {
			/* eh, fine. don't do separate func. */
			if i == 0 {
				rv += fmt.Sprintf("%s", id)
			}
			if i > 0 {
				rv += "else "
			}
			rv += fmt.Sprintf("if %s == %s {\n", d.expr.kname, d.scls[i].expr.kname)
			for j, _ := range d.scls[i].scls {
				rv += c.compileClause(incnt+1, d.scls[i].scls[j])
			}
			rv += fmt.Sprintf("%s} ", id)
			if i == len(d.scls)-1 {
				rv += "\n"
			}
		}
	case CKINDEXIT:
		rv += id + "return\n"
	case CKINDDEBUG:
		rv += c.compileExpr(incnt, d.expr, false)
		rv += fmt.Sprintf("%sprintf(\"%%s\\n\", %s)\n", id, d.expr.kname)
	case CKINDSTORE:
		/* get database */
		rv += c.compileExpr(incnt, d.exprs[0], false)
		rv += c.compileExpr(incnt, d.exprs[1], false)
		rv += c.compileExpr(incnt, d.exprs[2], false)
		slookupnm := c.gensym()
		rv += fmt.Sprintf("%svar %s []ui8\n%s%s = %s\n", id, slookupnm, id, slookupnm, c.compileSerializeLookup(d.exprs[1].typ, d.exprs[1].kname))
		sresnm := c.gensym()
		rv += fmt.Sprintf("%svar %s []ui8\n", id, sresnm) //compileType(d.typ, true))
		rv += fmt.Sprintf("%s%s = %s\n", id, sresnm, c.compileSerialize(d.exprs[2].typ, d.exprs[2].kname))
		okbool := c.gensym()
		rv += fmt.Sprintf("%svar %s bool\n", id, okbool)
		rv += fmt.Sprintf("%s%s = cxdatum.store(%s, %s, %s)\n", id, okbool, d.exprs[0].kname, slookupnm, sresnm)
	case CKINDEXPR:
		rv += c.compileExpr(incnt, d.expr, true)
		/* backprop!!! */
		for i := len(backstack) - 1; i >= 0; i-- {
			rv += backstack[i]
		}
		backstack = []string{} /* eBic. */
	default:
		panic("unknown statement/clause type!")
	}
	return rv + "\n"
}

func (c *Compiler) compileFor(incnt int, d *DClause) string {
	rv := ""
	cnt := c.gensym()
	id := strings.Repeat("\t", incnt)
	//we need to get the length of whatever the expression is
	//but first we need the expression.
	rv += c.compileExpr(incnt, d.expr.rhs, false) //this is correct
	var denom string
	switch d.expr.fld.typ.tkind {
	case TKINDWALLET:
		denom = " / 25"
	case TKINDHASH:
		denom = " / 32"
	}
	rv += fmt.Sprintf("\n%sfor %s := 0; %s < len(%s)%s; %s++ {\n", id, cnt, cnt, d.expr.rhs.kname, denom, cnt)
	/* needs to know what index code to use. since rhs is []str, []ui8, []hash, or []wallet...*/
	rv += c.compileVar(incnt+1, d.expr.fld)
	rv += fmt.Sprintf("%s\t%s = %s\n", id, d.expr.fld.name, c.compileAppend(d.expr.fld.typ, true, d.expr.rhs.kname, cnt))
	for i, _ := range d.scls {
		rv += c.compileClause(incnt+1, d.scls[i])
	}
	rv += fmt.Sprintf("%s}\n\n", id)
	return rv
}

func (c *Compiler) compileVar(incnt int, d *DField) string {
	rv := strings.Repeat("\t", incnt)
	rv += fmt.Sprintf("var %s %s\n", d.name, compileType(d.typ, true))
	return rv
}

func (c *Compiler) compileExpr(incnt int, d *DExpr, back bool) string {
	/* this is tricky, because we walk the root before we get anywhere */
	/* conversions can be tricky */
	rv := ""
	switch d.ekind {
	case EKINDPRIME:
		if d.typ.tkind == TKINDSTRING && d.typ.islit {
			/* string literal */
			strlitnm := c.gensym()
			id := strings.Repeat("\t", incnt)
			rv += fmt.Sprintf("%svar %s str\n%s%s = \"%s\"\n", id, strlitnm, id, strlitnm, d.lit)
			d.kname = strlitnm
		} else if d.typ.tkind == TKINDINT && d.typ.islit {
			numlitnm := c.gensym()
			id := strings.Repeat("\t", incnt)
			rv += fmt.Sprintf("%svar %s i32\n%s%s = %d\n", id, numlitnm, id, numlitnm, d.left)
			d.kname = numlitnm
		} else {
			if d.typ.tkind == TKINDDATABASE {
				d.kname = d.fld.typ.dbase.name
			} else {
				d.kname = d.fld.name
			}
		}
	case EKINDLOOKUP:
		/* reasonably simple. (1) create svar, (2) do lookup, (3) create realvar, (4) deserialize. */
		rv += c.compileExpr(incnt, d.rhs, false) /* stores unserialized variable name in kname */
		id := strings.Repeat("\t", incnt)
		slookupnm := c.gensym()
		rv += fmt.Sprintf("%svar %s []ui8\n%s%s = %s\n", id, slookupnm, id, slookupnm, c.compileSerializeLookup(d.rhs.typ, d.rhs.kname))
		sresnm := c.gensym()
		rv += fmt.Sprintf("%svar %s []ui8\n", id, sresnm) //compileType(d.typ, true))
		rv += fmt.Sprintf("%s%s = cxdatum.fetch(%s, %s)\n", id, sresnm, d.lhs.fld.typ.dbase.name, slookupnm)
		/* decode */
		rvs_ := ""
		resnm := ""
		if d.typ.tkind == TKINDDATUM {
			/* might need to create variable */
			resnm = c.gensym()
			rvs_ = fmt.Sprintf("%svar %s %s\n", id, resnm, d.typ.datum.name)
			dscd := fmt.Sprintf("%s = deserialize%s(%s)", resnm, d.typ.datum.name, sresnm)
			rvs_ += fmt.Sprintf("%sif len(%s) == 0 {\n%s\t%s = %s{}\n%s} else {\n%s\t%s\n%s}\n", id, sresnm, id, resnm, d.typ.datum.name, id, id, dscd, id)
		} else {
			rvs_, resnm = c.compileDeserialize(incnt, d.typ, sresnm)
		}
		rv += rvs_
		d.kname = resnm
		/* generate backprop code and push to stack */
		/* we need to first reserialize the object created, (resnm), then cxdatum.store that bitch, and we done. */
		if back {
			bkrv := ""
			sstonm := c.gensym()
			bkrv += fmt.Sprintf("%svar %s []ui8\n", id, sstonm)
			bkrv += fmt.Sprintf("%s%s = %s\n", id, sstonm, c.compileSerialize(d.typ, resnm))
			oknm := c.gensym()
			bkrv += fmt.Sprintf("%svar %s bool\n", id, oknm)
			bkrv += fmt.Sprintf("%s%s = cxdatum.store(%s, %s, %s)\n", id, oknm, d.lhs.fld.typ.dbase.name, slookupnm, sstonm)
			backstack = append(backstack, bkrv)
		}
	case EKINDSELECT:
		/* simple. lhs is previous code, typ is type, fld is field */
		rv += c.compileExpr(incnt, d.lhs, back)
		id := strings.Repeat("\t", incnt)
		drfnm := c.gensym()
		rv += fmt.Sprintf("%svar %s %s\n", id, drfnm, compileType(d.typ, true))
		rv += fmt.Sprintf("%s%s = %s.%s\n", id, drfnm, d.lhs.kname, d.fld.name)
		d.kname = drfnm
		if back {
			bkrv := ""
			bkrv += fmt.Sprintf("%s%s.%s = %s\n", id, d.lhs.kname, d.fld.name, drfnm)
			backstack = append(backstack, bkrv)
		}
	case EKINDTO:
		rv += c.compileExpr(incnt, d.lhs, back)
		/* this code is so complex that I will wait until tomorrow to write. */
		torv, kn := c.compileTo(incnt, d.left, d.lhs.typ, d.typ, d.lhs.kname, "", back)
		d.kname = kn
		rv += torv
	case EKINDSLICE:
		/* actually pretty simple. works on array of byte or array[X] of byte */
		rv += c.compileExpr(incnt, d.lhs, back)
		id := strings.Repeat("\t", incnt)
		if d.lhs.typ.tkind != TKINDBYTE {
			panic("cannot slice array or fixed array of array type: " + dtypeToString(d.lhs.typ))
		}
		/* straightforward. plus final thing for back! */
		slnm := c.gensym()
		rv += fmt.Sprintf("%svar %s []ui8\n", id, slnm)
		cnt := c.gensym()
		rv += fmt.Sprintf("%sfor %s := %d; %s < %d && %s < len(%s); %s++ {\n", id, cnt, d.left, cnt, d.right, cnt, d.lhs.kname, cnt)
		rv += fmt.Sprintf("%s\t%s = append(%s, %s[%s])\n%s}\n", id, slnm, slnm, d.lhs.kname, cnt, id)
		d.kname = slnm
		/* it's backprop time */
		if back {
			bkrv := ""
			ncnt := c.gensym()
			bkrv += fmt.Sprintf("%sfor %s := 0; %s < %d && %s < len(%s); %s++ {\n", id, ncnt, ncnt, d.right-d.left, ncnt, slnm, ncnt)
			bkrv += fmt.Sprintf("%s\t%s[%s + %d] = %s[%s]\n%s}\n", id, d.lhs.kname, ncnt, d.left, slnm, ncnt, id)
			backstack = append(backstack, bkrv)
		}
	case EKINDNEW:
		/* simply creates a new thingy. */
		id := strings.Repeat("\t", incnt)
		newnm := c.gensym()
		rv += fmt.Sprintf("%svar %s %s\n", id, newnm, d.typ.datum.name)
		rv += fmt.Sprintf("%s%s = %s{}\n", id, newnm, d.typ.datum.name)
		d.kname = newnm
	case EKINDSET:
		/* expr.lhs = expr.rhs; i.e., compile lhs (back), then rhs (false), then set lhs.kname's var to rhs.kname */
		id := strings.Repeat("\t", incnt)
		rv += c.compileExpr(incnt, d.lhs, back)
		rv += c.compileExpr(incnt, d.rhs, false)
		rv += fmt.Sprintf("%s%s = %s\n", id, d.lhs.kname, d.rhs.kname)
		/* expression has no kname */
	case EKINDAPPEND:
		/* very, very difficult. Could be one of many potential options. */
		id := strings.Repeat("\t", incnt)
		rv += c.compileExpr(incnt, d.lhs, back)
		rv += c.compileExpr(incnt, d.rhs, false)
		rv += fmt.Sprintf("%s%s = %s\n", id, d.lhs.kname, c.compileAppend(d.rhs.typ, false, d.lhs.kname, d.rhs.kname))
	case EKINDINC:
		id := strings.Repeat("\t", incnt)
		/* simple enough */
		rv += c.compileExpr(incnt, d.lhs, back)
		rv += fmt.Sprintf("%s%s++\n", id, d.lhs.kname)
	case EKINDDEC:
		id := strings.Repeat("\t", incnt)
		/* simple enough */
		rv += c.compileExpr(incnt, d.lhs, back)
		rv += fmt.Sprintf("%s%s--\n", id, d.lhs.kname)
	default:
		panic("unknown expression!")
	}

	return rv
}

func (c *Compiler) compileTo(incnt int, tocode int, from *DType, to *DType, fvar string, tvar string, back bool) (string, string) {
	id := strings.Repeat("\t", incnt)
	rv := id
	var tonm string
	if tvar == "" {
		tonm = c.gensym()
		rv += fmt.Sprintf("var %s %s\n%s", tonm, compileType(to, true), id)
	} else {
		tonm = tvar
	}
	switch tocode {
	case ABYTE_TO_BYTE:
		/* copy over things */
		cnt := c.gensym()
		rv += fmt.Sprintf("for %s := 0; %s < %d; %s++ {\n", cnt, cnt, from.asize, cnt)
		rv += fmt.Sprintf("%s\t%s = append(%s, %s[%s])\n%s}\n", id, tonm, tonm, fvar, cnt, id)
		if back {
			/* you know the drill */
			bkrv, _ := c.compileTo(incnt, BYTE_TO_ABYTE, to, from, tonm, fvar, false)
			backstack = append(backstack, bkrv)
		}
	case BYTE_TO_ABYTE:
		cnt := c.gensym()
		rv += fmt.Sprintf("for %s := 0; %s < len(%s); %s++ {\n", cnt, cnt, fvar, cnt)
		rv += fmt.Sprintf("%s\t%s[%s] = %s[%s]\n%s}\n", id, tonm, cnt, fvar, cnt, id)
		if back {
			bkrv, _ := c.compileTo(incnt, ABYTE_TO_BYTE, to, from, tonm, fvar, false)
			backstack = append(backstack, bkrv)
		}
	case STRING_TO_HASH:
		rv += fmt.Sprintf("%s = stringToSha(%s)\n", tonm, fvar)
		if back {
			bkrv, _ := c.compileTo(incnt, HASH_TO_STRING, to, from, tonm, fvar, false)
			backstack = append(backstack, bkrv)
		}
	case STRING_TO_WALLET:
		rv += fmt.Sprintf("%s = cxdatum.btaddress(%s)\n", tonm, fvar)
		if back {
			bkrv, _ := c.compileTo(incnt, WALLET_TO_STRING, to, from, tonm, fvar, false)
			backstack = append(backstack, bkrv)
		}
	case HASH_TO_STRING:
		rv += fmt.Sprintf("%s = shaToHex(%s)\n", tonm, fvar)
		if back {
			bkrv, _ := c.compileTo(incnt, STRING_TO_HASH, to, from, tonm, fvar, false)
			backstack = append(backstack, bkrv)
		}
	case WALLET_TO_STRING:
		rv += fmt.Sprintf("%s = cxdatum.rdaddress(%s)\n", tonm, fvar)
		if back {
			bkrv, _ := c.compileTo(incnt, STRING_TO_WALLET, to, from, tonm, fvar, false)
			backstack = append(backstack, bkrv)
		}
	case HASH_TO_ABYTE, WALLET_TO_ABYTE, ABYTE_TO_HASH, ABYTE_TO_WALLET:
		/* simple actually lol. WAIT --  */
		rv = ""
		tonm = fvar
	case HASH_TO_BYTE:
		/* copy and append */
		cnt := c.gensym()
		rv += fmt.Sprintf("for %s := 0; %s < %d; %s++ {\n", cnt, cnt, 32, cnt)
		rv += fmt.Sprintf("%s\t%s = append(%s, %s[%s])\n%s}\n", id, tonm, tonm, fvar, cnt, id)
		if back {
			bkrv, _ := c.compileTo(incnt, BYTE_TO_HASH, to, from, tonm, fvar, false)
			backstack = append(backstack, bkrv)
		}
	case WALLET_TO_BYTE:
		cnt := c.gensym()
		rv += fmt.Sprintf("for %s := 0; %s < %d; %s++ {\n", cnt, cnt, 25, cnt)
		rv += fmt.Sprintf("%s\t%s = append(%s, %s[%s])\n%s}\n", id, tonm, tonm, fvar, cnt, id)
		if back {
			bkrv, _ := c.compileTo(incnt, BYTE_TO_WALLET, to, from, tonm, fvar, false)
			backstack = append(backstack, bkrv)
		}
	case BYTE_TO_HASH, BYTE_TO_WALLET:
		cnt := c.gensym()
		rv += fmt.Sprintf("for %s := 0; %s < len(%s); %s++ {\n", cnt, cnt, fvar, cnt)
		rv += fmt.Sprintf("%s\t%s[%s] = %s[%s]\n%s}\n", id, tonm, cnt, fvar, cnt, id)
		if tocode == BYTE_TO_HASH {
			if back {
				bkrv, _ := c.compileTo(incnt, HASH_TO_BYTE, to, from, tonm, fvar, false)
				backstack = append(backstack, bkrv)
			}
		} else {
			if back {
				bkrv, _ := c.compileTo(incnt, WALLET_TO_BYTE, to, from, tonm, fvar, false)
				backstack = append(backstack, bkrv)
			}
		}
	case STRING_TO_BYTE:
		rv += fmt.Sprintf("%s = cxdatum.str2bytes(%s)\n", tonm, fvar)
		if back {
			bkrv, _ := c.compileTo(incnt, BYTE_TO_STRING, to, from, tonm, fvar, false)
			backstack = append(backstack, bkrv)
		}
	case STRING_TO_ABYTE, ABYTE_TO_STRING:
		panic("cannot compile string to array [X] of byte (or vice versa)!")
	case BYTE_TO_STRING:
		rv += fmt.Sprintf("%s = cxdatum.bytes2str(%s)\n", tonm, fvar)
		if back {
			bkrv, _ := c.compileTo(incnt, STRING_TO_BYTE, to, from, tonm, fvar, false)
			backstack = append(backstack, bkrv)
		}
	case BYTE_TO_DATUM:
		rv += fmt.Sprintf("%s = deserialize%s(%s)\n", tonm, to.datum.name, fvar)
		if back {
			bkrv, _ := c.compileTo(incnt, DATUM_TO_BYTE, to, from, tonm, fvar, false)
			backstack = append(backstack, bkrv)
		}
	case DATUM_TO_BYTE:
		rv += fmt.Sprintf("%s = serialize%s(%s)\n", tonm, from.datum.name, fvar)
		if back {
			bkrv, _ := c.compileTo(incnt, BYTE_TO_DATUM, to, from, tonm, fvar, false)
			backstack = append(backstack, bkrv)
		}
	default:
		panic("unsupported X to Y conversion!")
	}

	return rv, tonm
}

func (c *Compiler) compileSerialize(typ *DType, nm string) string {
	rv := ""
	if typ.tkind != TKINDBYTE {
		rv += "serialize"
		switch typ.tkind {
		case TKINDINT:
			rv += "I32"
		case TKINDSTRING:
			rv += "Str"
		case TKINDWALLET:
			rv += "Wal"
		case TKINDHASH:
			rv += "Sha"
		case TKINDDATUM:
			rv += typ.datum.name
		}
		if typ.array {
			rv += "Slice"
		}
		return rv + "(" + nm + ")"
	} else {
		return nm
	}
}

func (c *Compiler) compileSerializeLookup(typ *DType, nm string) string {
	switch typ.tkind {
	case TKINDSTRING:
		return "cxdatum.str2bytes(" + nm + ")"
	case TKINDWALLET:
		return "serializeWal(" + nm + ")"
	case TKINDHASH:
		return "serializeSha(" + nm + ")"
	case TKINDDATUM:
		return "serialize" + typ.datum.name + "(" + nm + ")"
	case TKINDBYTE:
		return nm
	}

	return ""
}

func (c *Compiler) compileDatabases() {
	rv := "package model\n\nimport \"cxdatum\"\n\n"
	for k, v := range c.dbs {
		v.name = "db" + k
		rv += fmt.Sprintf("var %s str\n", v.name)
	}
	rv += "var dbmeta str\n"
	rv += "\n\nfunc initdb() {\n\tvar ok bool\n"
	for k, v := range c.dbs {
		rv += fmt.Sprintf("\t%s = \"%s\"\n\tok = cxdatum.bucket(%s)\n", v.name, k, v.name)
	}
	/* we also need to add one final bucket: the meta bucket. */
	rv += fmt.Sprintf("\tdbmeta = \"meta\"\n\tok = cxdatum.bucket(dbmeta)\n")
	rv += "}\n\n"
	c.cxdbase = rv
}

func (c *Compiler) compileDatum(d *DGlause) {
	/* so this compiles:
	 * - struct on CX
	 * - struct on Go
	 * - serialization function on CX
	 * - deserialization function on CX
	 * - serialization function on Go
	 * - deserialization function on Go
	 */
	cxstruct := compileDatumStruct(d, true)
	gostruct := compileDatumStruct(d, false)
	cxser := c.compileDatumCXSer(d)
	goser := c.compileDatumGoSer(d)
	cxdser := c.compileDatumCXDser(d)
	godser := c.compileDatumGoDser(d)
	c.cxmodel += cxstruct
	c.gomodel += gostruct
	c.cxser += cxser
	c.goser += goser
	c.cxdser += cxdser
	c.godser += godser
}

func (c *Compiler) gensym() string {
	c.gensymc++
	return c.gensymp + fmt.Sprintf("%d", c.gensymc)
}

func (c *Compiler) compileDatumGoDser(d *DGlause) string {
	totmp := c.gensym() + d.name
	rv := fmt.Sprintf("func deserialize%s (b []byte) %s {\n\t%s := %s{}\n\tslen := len(b)\n\tif slen == 0 {\n\t\treturn %s\n\t}\n", d.name, d.name, totmp, d.name, totmp)
	for i, _ := range d.fields {
		typ := d.fields[i].typ
		switch typ.tkind {
		case TKINDDATUM:
			/* we CAN allow datum field if it is a special kind of datum. */
			/* i.e., a datum which only has one field--- of type datum. */
			rv += fmt.Sprintf("\t%s.%s = deserialize%s(b)\n", totmp, d.fields[i].name, typ.datum.name)
		case TKINDBYTE:
			if typ.array {
				if typ.asize > 0 {
					rv += fmt.Sprintf("\tcopy(%s.%s[:], b[:%d])\n\tb = b[%d:]\n", totmp, d.fields[i].name, typ.asize, typ.asize)
				} else {
					rv += fmt.Sprintf("\tslen = makeInt(b[:4])\n\tb = b[4:]\n\t%s.%s = b[:slen]\n\tb = b[slen:]\n", totmp, d.fields[i].name)
				}
			}
		case TKINDINT:
			if typ.array {
				rv += fmt.Sprintf("\tslen = makeInt(b[:4])\n\tb = b[4:]\n\tfor i := 0; i < slen; i++ {\n\t\t%s.%s = append(%s.%s, makeInt(b[:4]))\n\t\tb = b[4:]\n\t}\n", totmp, d.fields[i].name, totmp, d.fields[i].name)
			} else {
				rv += fmt.Sprintf("\t%s.%s = makeInt(b[:4])\n\tb = b[4:]\n", totmp, d.fields[i].name)
			}
		case TKINDHASH:
			if typ.array {
				rv += fmt.Sprintf("\tslen = makeInt(b[:4])\n\tb = b[4:]\n\tfor i := 0; i < slen; i++ {\n\t\ttmp__, _ := cipher.SHA256FromBytes(b[:32])\n\t\t%s.%s = append(%s.%s, tmp__)\n\t\tb = b[32:]\n\t}\n", totmp, d.fields[i].name, totmp, d.fields[i].name)
			} else {
				rv += fmt.Sprintf("\t%s.%s, _ = cipher.SHA256FromBytes(b[:32])\n\tb = b[32:]\n", totmp, d.fields[i].name)
			}
		case TKINDWALLET:
			if typ.array {
				rv += fmt.Sprintf("\tslen = makeInt(b[:4])\n\tb = b[4:]\n\tfor i := 0; i < slen; i++ {\n\t\ttmp__, _ := cipher.AddressFromBytes(b[:25])\n\t\t%s.%s = append(%s.%s, tmp__)\n\t\tb = b[25:]\n\t}\n", totmp, d.fields[i].name, totmp, d.fields[i].name)
			} else {
				rv += fmt.Sprintf("\t%s.%s, _ = cipher.AddressFromBytes(b[:25])\n\tb = b[25:]\n", totmp, d.fields[i].name)
			}
		case TKINDSTRING:
			if typ.array {
				rv += fmt.Sprintf("\tslen = makeInt(b[:4])\n\tb = b[4:]\n\tfor i := 0; i < slen; i++ {\n\t\ttmp__ := makeInt(b[:4])\n\t\tb = b[4:]\n\t\t%s.%s = append(%s.%s, string(b[:tmp__]))\n\t\tb = b[tmp__:]\n\t}\n", totmp, d.fields[i].name, totmp, d.fields[i].name)
			} else {
				rv += fmt.Sprintf("\tslen = makeInt(b[:4])\n\tb = b[4:]\n\t%s.%s = string(b[:slen])\n\tb = b[slen:]\n", totmp, d.fields[i].name)
			}
		}
	}
	rv += fmt.Sprintf("\treturn %s\n}\n\n", totmp)
	return rv
}

func (c *Compiler) compileDatumCXDser(d *DGlause) string {
	rv := fmt.Sprintf("func deserialize%s (obj []ui8) (out %s) {\n\tvar idx i32\n", d.name, d.name)
	var syms []string
	for i, _ := range d.fields {
		/* depending on what kind of field it is, we need to serialize it */
		/* this is what we do now. */
		typ := d.fields[i].typ
		loctmp := c.gensym() + d.fields[i].name
		syms = append(syms, fmt.Sprintf("%s: %s", d.fields[i].name, loctmp))
		rv += fmt.Sprintf("\tvar %s %s\n", loctmp, compileType(d.fields[i].typ, true))
		switch typ.tkind {
		case TKINDBYTE:
			/* easy peasy */
			if typ.array {
				cnt := c.gensym()
				if typ.asize > 0 {
					rv += fmt.Sprintf("\tfor %s := 0; %s < %d; %s++ {\n\t\t%s[%s] = obj[idx]\n\t\tidx++\n\t}\n",
						cnt, cnt, typ.asize, cnt, loctmp, cnt)
				} else {
					/* we need to decode length too :( */
					loctmplen := c.gensym() + d.fields[i].name
					rv += fmt.Sprintf("\tvar %s i32\n\t%s = deserializeI32(obj, &idx)\n", loctmplen, loctmplen)
					loctmplencnt := c.gensym() + d.fields[i].name
					rv += fmt.Sprintf("\tfor %s := 0; %s < %s; %s++ {\n\t\t%s = append(%s, obj[idx])\n\t\tidx++\n\t}\n",
						loctmplencnt, loctmplencnt, loctmplen, loctmplencnt, loctmp, loctmp)
				}
			} else {
				panic("cannot have raw byte.")
			}
		case TKINDINT:
			if typ.array {
				rv += fmt.Sprintf("\t%s = deserializeI32Slice(obj, &idx)\n", loctmp)
			} else {
				rv += fmt.Sprintf("\t%s = deserializeI32(obj, &idx)\n", loctmp)
			}
		case TKINDSTRING, TKINDWALLET, TKINDHASH:
			slc := ""
			if typ.tkind == TKINDSTRING {
				slc += "Str"
			} else if typ.tkind == TKINDWALLET {
				slc += "Wal"
			} else {
				slc += "Sha"
			}
			if typ.array {
				slc += "Slice"
			}
			rv += fmt.Sprintf("\t%s = deserialize"+slc+"(obj, &idx)\n", loctmp)
		case TKINDDATUM:
			/* we CAN allow datum field if it is a special kind of datum. */
			/* i.e., a datum which only has one field--- of type datum. */
			rv += fmt.Sprintf("\t%s = deserialize%s(obj)\n", loctmp, typ.datum.name)
		case TKINDDATABASE:
			panic("cannot have datum field of type datum or database!")
		}
	}

	rv += fmt.Sprintf("\tout = %s{%s}\n}\n\n", d.name, strings.Join(syms, ", "))
	return rv
}

func (c *Compiler) compileDeserialize(incnt int, d *DType, svar string) (string, string) {
	rv := ""
	id := strings.Repeat("\t", incnt)
	typ := d
	loctmp := c.gensym()
	rv += fmt.Sprintf("%svar %s %s\n", id, loctmp, compileType(typ, true))
	switch typ.tkind {
	case TKINDBYTE:
		if typ.array {
			cnt := c.gensym()
			if typ.asize > 0 {
				rv += fmt.Sprintf("%sfor %s := 0; %s < %d; %s++ {\n%s\t%s[%s] = %s[%s]\n%s}\n",
					id, cnt, cnt, typ.asize, cnt, id, loctmp, cnt, svar, cnt, id)
			} else {
				loctmplen := c.gensym()
				locidx := c.gensym()
				rv += fmt.Sprintf("%svar %s i32\n", id, locidx)
				rv += fmt.Sprintf("%svar %s i32\n", id, loctmplen)
				rv += fmt.Sprintf("%s%s = deserializeI32(%s, &%s)\n", id, loctmplen, svar, locidx)
				rv += fmt.Sprintf("%sfor %s := 0; %s < %s; %s++ {\n", id, cnt, cnt, loctmplen, cnt)
				rv += fmt.Sprintf("\n%s\t%s = append(%s, %s[4+%s])\n%s}\n",
					id, loctmp, loctmp, svar, cnt, id)
			}
		} else {
			panic("cannot have raw byte.")
		}
	case TKINDINT:
		if typ.array {
			locidx := c.gensym()
			rv += fmt.Sprintf("%svar %s i32\n", id, locidx)
			rv += fmt.Sprintf("%s%s = deserializeI32Slice(%s, &%s)\n", id, loctmp, svar, locidx)
		} else {
			locidx := c.gensym()
			rv += fmt.Sprintf("%svar %s i32\n", id, locidx)
			rv += fmt.Sprintf("%s%s = deserializeI32(%s, &%s)\n", id, loctmp, svar, locidx)
		}
	case TKINDSTRING, TKINDWALLET, TKINDHASH:
		slc := ""
		if typ.tkind == TKINDSTRING {
			slc += "Str"
		} else if typ.tkind == TKINDWALLET {
			slc += "Wal"
		} else {
			slc += "Sha"
		}
		if typ.array {
			slc += "Slice"
		}
		locidx := c.gensym()
		rv += fmt.Sprintf("%svar %s i32\n", id, locidx)
		rv += fmt.Sprintf("%s%s = deserialize"+slc+"(%s, &%s)\n", id, loctmp, svar, locidx)
	case TKINDDATUM:
		rv += fmt.Sprintf("%s%s = deserialize%s(%s)\n", id, loctmp, typ.datum.name, svar)
	case TKINDDATABASE:
		panic("cannot deserialize for type database!")
	}

	return rv, loctmp
}

func (c *Compiler) compileDatumGoSer(d *DGlause) string {
	rv := fmt.Sprintf("func serialize%s (obj %s) []byte {\n\tvar out []byte\n", d.name, d.name)
	for i, _ := range d.fields {
		typ := d.fields[i].typ
		switch typ.tkind {
		case TKINDBYTE:
			if typ.array {
				if typ.asize > 0 {
					rv += fmt.Sprintf("\tout = append(out, obj.%s[:]...)\n", d.fields[i].name)
				} else {
					rv += fmt.Sprintf("\tout = append(out, obj.%s...)\n", d.fields[i].name)
				}
			}
		case TKINDINT:
			if typ.array {
				rv += fmt.Sprintf("\tout = append(out, breakInt(len(obj.%s))...)\n", d.fields[i].name)
				rv += fmt.Sprintf("\tfor i := 0; i < len(obj.%s); i++ {\n", d.fields[i].name)
				rv += fmt.Sprintf("\t\tout = append(out, breakInt(obj.%s[i])...)\n\t}\n", d.fields[i].name)
			} else {
				rv += fmt.Sprintf("\tout = append(out, breakInt(obj.%s)...)\n", d.fields[i].name)
			}
		case TKINDHASH, TKINDWALLET, TKINDSTRING:
			loctmpstr := ""
			loctmparr := "[i]"
			if !typ.array {
				loctmparr = ""
			}
			if typ.tkind == TKINDHASH {
				loctmpstr += fmt.Sprintf("obj.%s%s[:]", d.fields[i].name, loctmparr)
			} else if typ.tkind == TKINDSTRING {
				/* wrong! needs to encode length. */
				loctmpstr += fmt.Sprintf("append(breakInt(len(obj.%s%s)), []byte(obj.%s%s)...)", d.fields[i].name, loctmparr, d.fields[i].name, loctmparr)
			} else if typ.tkind == TKINDWALLET {
				loctmpstr += fmt.Sprintf("obj.%s%s.Bytes()", d.fields[i].name, loctmparr)
			}
			if typ.array {
				rv += fmt.Sprintf("\tout = append(out, breakInt(len(obj.%s))...)\n", d.fields[i].name)
				rv += fmt.Sprintf("\tfor i := 0; i < len(obj.%s); i++ {\n\t\tout = append(out, %s...)\n\t}\n", d.fields[i].name, loctmpstr)
			} else {
				rv += fmt.Sprintf("\tout = append(out, %s...)\n", loctmpstr)
			}
		case TKINDDATUM:
			/* we CAN allow datum field if it is a special kind of datum. */
			/* i.e., a datum which only has one field--- of type datum. */
			rv += fmt.Sprintf("\tout = serialize%s(obj.%s)\n", typ.datum.name, d.fields[i].name)
		case TKINDDATABASE:
			panic("cannot have datum field of type datum or database!")
		}
	}
	rv += "\treturn out\n}\n\n"
	return rv
}

func (c *Compiler) compileDatumCXSer(d *DGlause) string {
	/* for this, it certainly is easier to do golang and CX separate */
	rv := fmt.Sprintf("func serialize%s (obj %s) (out []ui8) {\n", d.name, d.name)
	/* we compile each field in order */
	for i, _ := range d.fields {
		/* depending on what kind of field it is, we need to serialize it */
		/* this is what we do now. */
		typ := d.fields[i].typ
		loctmp := c.gensym() + d.fields[i].name
		rv += fmt.Sprintf("\tvar %s %s\n", loctmp, compileType(d.fields[i].typ, true))
		rv += fmt.Sprintf("\t%s = obj.%s\n", loctmp, d.fields[i].name)
		switch typ.tkind {
		case TKINDBYTE:
			/* easy peasy */
			if typ.array {
				cnt := c.gensym()
				if typ.asize > 0 {
					rv += fmt.Sprintf("\tfor %s := 0; %s < %d; %s++ {\n\t\tout = append(out, %s[%s])\n\t}\n",
						cnt, cnt, typ.asize, cnt, loctmp, cnt)
				} else {
					/* we need to encode length too :( */
					loctmplen := c.gensym() + d.fields[i].name
					rv += fmt.Sprintf("\tvar %s [4]ui8\n\t%s = serializeI32(len(%s))\n", loctmplen, loctmplen, loctmp)
					loctmplencnt := c.gensym() + d.fields[i].name
					rv += fmt.Sprintf("\tfor %s := 0; %s < 4; %s++ {\n\t\tout = append(out, %s[%s])\n\t}\n",
						loctmplencnt, loctmplencnt, loctmplencnt, loctmplen, loctmplencnt)
					rv += fmt.Sprintf("\tfor %s := 0; %s < len(%s); %s++ {\n\t\tout = append(out, %s[%s])\n\t}\n",
						cnt, cnt, loctmp, cnt, loctmp, cnt)
				}
			} else {
				panic("cannot have raw byte.")
			}
		case TKINDINT:
			if typ.array {
				loctmpi32 := c.gensym() + d.fields[i].name
				rv += fmt.Sprintf("\tvar %s []ui8\n\t%s = serializeI32Slice(%s)\n", loctmpi32, loctmpi32, loctmp)
				loctmplencnt := c.gensym() + d.fields[i].name
				rv += fmt.Sprintf("\tfor %s := 0; %s < len(%s); %s++ {\n\t\tout = append(out, %s[%s])\n\t}\n",
					loctmplencnt, loctmplencnt, loctmpi32, loctmplencnt, loctmpi32, loctmplencnt)
			} else {
				loctmplen := c.gensym() + d.fields[i].name
				rv += fmt.Sprintf("\tvar %s [4]ui8\n\t%s = serializeI32(%s)\n", loctmplen, loctmplen, loctmp)
				loctmplencnt := c.gensym() + d.fields[i].name
				rv += fmt.Sprintf("\tfor %s := 0; %s < 4; %s++ {\n\t\tout = append(out, %s[%s])\n\t}\n",
					loctmplencnt, loctmplencnt, loctmplencnt, loctmplen, loctmplencnt)
			}
		case TKINDSTRING, TKINDWALLET, TKINDHASH:
			slc := ""
			if typ.tkind == TKINDSTRING {
				slc += "Str"
			} else if typ.tkind == TKINDWALLET {
				slc += "Wal"
			} else {
				slc += "Sha"
			}
			if typ.array {
				slc += "Slice"
			}
			loctmplen := c.gensym() + d.fields[i].name
			rv += fmt.Sprintf("\tvar %s []ui8\n\t%s = serialize"+slc+"(%s)\n", loctmplen, loctmplen, loctmp)
			loctmplencnt := c.gensym() + d.fields[i].name
			rv += fmt.Sprintf("\tfor %s := 0; %s < len(%s); %s++ {\n\t\tout = append(out, %s[%s])\n\t}\n",
				loctmplencnt, loctmplencnt, loctmplen, loctmplencnt, loctmplen, loctmplencnt)
		case TKINDDATUM:
			/* we CAN allow datum field if it is a special kind of datum. */
			/* i.e., a datum which only has one field--- of type datum. */
			rv += fmt.Sprintf("\tout = serialize%s(%s)\n", typ.datum.name, loctmp)
		case TKINDDATABASE:
			panic("cannot have datum field of type datum or database!")
		}
	}
	rv += "}\n\n"
	return rv
}

func compileDatumStruct(d *DGlause, iscx bool) string {
	rv := fmt.Sprintf("type %s struct {\n", d.name)
	for i, _ := range d.fields {
		rv += fmt.Sprintf("\t%s %s\n", d.fields[i].name, compileType(d.fields[i].typ, iscx))
	}
	rv += "}\n\n"
	return rv
}

func compileType(d *DType, iscx bool) string {
	var rv string
	/* note that we can compile array types first */
	if d.array {
		rv += "["
		if d.asize > 0 {
			rv += strconv.FormatInt(int64(d.asize), 10)
		}
		rv += "]"
	}
	switch d.tkind {
	case TKINDBYTE:
		if iscx {
			rv += "ui8"
		} else {
			rv += "byte"
		}
	case TKINDINT:
		if iscx {
			rv += "i32"
		} else {
			rv += "int"
		}
	case TKINDSTRING:
		if iscx {
			rv += "str"
		} else {
			rv += "string"
		}
	case TKINDDATABASE:
		panic("Cannot compile database type!")
	case TKINDHASH, TKINDWALLET:
		if iscx {
			if d.array {
				rv += "ui8"
			} else {
				if d.tkind == TKINDWALLET {
					rv += "[25]ui8"
				} else {
					rv += "[32]ui8"
				}
			}
		} else {
			if d.tkind == TKINDWALLET {
				rv += "cipher.Address"
			} else {
				rv += "cipher.SHA256"
			}
		}
	case TKINDDATUM:
		rv += d.datum.name
	default:
		panic("unknown type compilation!")
	}

	return rv
}

var stdcxmain string = `
package main

import "model"
import "cxdatum"

func extractThing(sl []ui8) (out []ui8) {
    for i := 1; i < len(sl); i++ {
        out = append(out, sl[i])
    }
}

func main()() {
    model.initdb()

    /* the following is generated by CXDatum. */

    var success bool
    success = cxdatum.launch()
    if !success {
        printf("abort - chain couldn't even launch\n")
        return
    }
    printf("[CXDATUM] launched blockchain.\n")
    /* get length */
    var lentidx i32 = 0
    var lent    i32
    var lentser []ui8
    var synclen i32
    var lentstr str
    lentstr = "meta"
    var yghs []ui8
    yghs = cxdatum.str2bytes("meta")
    lentser = cxdatum.fetch(model.dbmeta, yghs)
    if len(lentser) > 0 {
        lent = model.deserializeI32(lentser, &lentidx)
        printf("[CXDATUM] length retrieved from meta database.\n")
    } else {
        lent = 1
        printf("[CXDATUM] starting new length.\n")
    }
    synclen = cxdatum.chainlen()
    printf("[CXDATUM] got chain length from API: %d\n", synclen)
    if synclen == -1 {
        printf("abort - chain length invalid!\n")
        return
    }
    /* make account */
    var mksucc bool
    mksucc = cxdatum.mkaccount()
    if !mksucc {
        printf("abort - account failure\n")
        return
    }
    printf("[CXDATUM] account created. Grabbing blocks.\n")
	/* now we grab all the blocks in the world */
	lent = lent + 1
    for i := lent; i <= synclen; i++ {
	    if i < 1 {
		    printf("[CXDATUM] SKIPPING BLOCK %d.\n", i)
	    } else {
			var block []ui8
        	block = cxdatum.getblock(i)
        	model.ProcessIncoming(block)
        	printf("[CXDATUM] block %d processed successfully.\n", i)
	    }
    }
    lent = synclen
    /* launch the api */
    var ok bool
    ok = cxdatum.launchapi()
    if !ok {
        printf("api launch failed!")
        return
    }
	printf("[CXDATUM] API successfully launched.\n")
	var nlent i32
    /* everything should be processed, so it's time to do the loop */
`

var stdgomain string = `
package model

import (
	"github.com/SkycoinProject/skycoin/src/cipher"
)

var donereq chan bool
var doneres chan bool
var req chan []byte
var res chan []byte

func init() {
	donereq = make(chan bool)
	doneres = make(chan bool)
	req = make(chan []byte, 1)
	res = make(chan []byte, 1)
}

func waitForPrgmReturn() []byte {
	<-doneres
	return <-res
}

func passToPrgm(byts []byte) {
	req <- byts
	donereq <- true
}

`

var stdcxmainfooter string = ` else {
        printf("abort - unknown code!\n")
        return
    }
    nlent = cxdatum.chainlen()
    if nlent > lent {
        printf("[CXDATUM] new block(s) received (new length: %d), (old: %d)\n", nlent, lent)
        lent = lent + 1
        for i := lent; i <= nlent; i++ {
			var block []ui8
            block = cxdatum.getblock(i)
            model.ProcessIncoming(block)
            printf("[CXDATUM] block %d processed successfully.\n", i)
        }
    }
    lent = nlent
    var nlentser [4]ui8
    nlentser = model.serializeI32(lent)
    var nlenser []ui8
    for y := 0; y < 4; y++ {
        nlenser = append(nlenser, nlentser[y])
    }
    var nlentserok bool
    var tmpstr2 []ui8
    tmpstr2 = cxdatum.str2bytes("meta")
    nlentserok = cxdatum.store(model.dbmeta, tmpstr2, nlenser)
    if nlentserok {
        printf("[CXDATUM] meta database successfully updated.\n")
    } else {
        printf("[CXDATUM] meta database error: cannot write!\n")
    }
    cxdatum.expose(outgoing)
    printf("[CXDATUM] cycle has been completed.\n")
}
}

`

func (c *Compiler) compileMain() {
	/**
	 * this works like so:
	 * 1. get main ingress (used for generic block updates)
	 * 2. call main ingress during update call.
	 * 3. generate codes for each egress.
	 * 4. in main loop, for received, check first byte for ecode.
	 * 5. depending on ecode, call the appropriate egress.
	 */

	eccx := ""
	ecgo := ""
	ii := 0
	var egrs []*DGlause
	for _, v := range c.egrs {
		eccx += fmt.Sprintf("\tvar CXDATUM_EGRESS_CODE_%s ui8 = %dUB\n", v.name, ii)
		ecgo += fmt.Sprintf("const CXDATUM_EGRESS_CODE_%s = %d\n", v.name, ii)
		egrs = append(egrs, v)
		ii++
	}

	c.goegrs += stdgomain
	c.goegrs += ecgo

	/* egress expect has cx-side deserialization and go-side serialization (in use) */
	/* egress return has cx-side serialization and go-side deserialization (in use) */
	/* essentially, we make data on both ends for them. */
	for _, v := range c.egrs {
		c.compileDatum(&DGlause{
			name:   v.name + "_arg_EgressExpect",
			fields: v.expt,
		})
		c.compileDatum(&DGlause{
			name:   v.name + "_arg_EgressReturn",
			fields: v.ret,
		})
	}

	/* next, we need to do the main function's for loop */
	cxmain := stdcxmain
	cxmain += eccx
	cxmain += "\tfor i := 0; i < 1000000000; i++ {\n\t\tvar outgoing []ui8\n\t\tvar incoming []ui8\n\t\tincoming = cxdatum.stall()\n"
	/* once filled, incoming must be extracted. */
	extract := c.gensym()
	cxmain += fmt.Sprintf("\t\tvar %s []ui8\n\t\t%s = extractThing(incoming)\n", extract, extract)
	/* next comes the annoyingly long part */
	cxmain += "\t\tvar idx ui8 = incoming[0]\n"
	for i, v := range egrs {
		if i > 0 {
			cxmain += " else "
		}
		if i == 0 {
			cxmain += "\t\t"
		}
		cxmain += fmt.Sprintf("if idx == CXDATUM_EGRESS_CODE_%s {\n", v.name)
		/* deserialize extract */
		expt := c.gensym()
		cxmain += fmt.Sprintf("\t\t\tvar %s model.%s_arg_EgressExpect\n\t\t\t%s = model.deserialize%s_arg_EgressExpect(%s)\n", expt, v.name, expt, v.name, extract)
		/* move from fields to tmp vars */
		args := ""
		for j, _ := range v.expt {
			tmp := c.gensym()
			cxmain += c.compileVar(3, &DField{
				name: tmp,
				typ:  v.expt[j].typ,
			})
			cxmain += fmt.Sprintf("\t\t\t%s = %s.%s\n", tmp, expt, v.expt[j].name)
			args += tmp
			if j < len(v.expt)-1 {
				args += ", "
			}
		}
		/* insert call */
		cxmain += fmt.Sprintf("\t\t\toutgoing = model.%s(%s)\n", v.name, args)
		cxmain += "\t\t}"

		/* next, we need to compile the Go side of things. */
		goegrs := fmt.Sprintf("func %s (", v.name)
		/* this is reasonably simple. expect fields are input, return fields are output. */
		for j, _ := range v.expt {
			goegrs += fmt.Sprintf("%s %s", v.expt[j].name, compileType(v.expt[j].typ, false))
			if j < len(v.expt)-1 {
				goegrs += ", "
			}
		}
		goegrs += ") ("
		for j, _ := range v.ret {
			goegrs += fmt.Sprintf("%s %s", v.ret[j].name, compileType(v.ret[j].typ, false))
			if j < len(v.ret)-1 {
				goegrs += ", "
			}
		}
		goegrs += ") {\n"
		/* now we need to setup the transfer logic */
		expt = c.gensym()
		goegrs += fmt.Sprintf("\t%s := %s_arg_EgressExpect{}\n", expt, v.name)
		for j, _ := range v.expt {
			goegrs += fmt.Sprintf("\t%s.%s = %s\n", expt, v.expt[j].name, v.expt[j].name)
		}
		sexpt := c.gensym()
		goegrs += fmt.Sprintf("\t%s := []byte{CXDATUM_EGRESS_CODE_%s}\n", sexpt, v.name)
		goegrs += fmt.Sprintf("\t%s = append(%s, serialize%s_arg_EgressExpect(%s)...)\n", sexpt, sexpt, v.name, expt)

		/* then we perform the transfer */
		goegrs += fmt.Sprintf("\tpassToPrgm(%s)\n\t%s = waitForPrgmReturn()\n", sexpt, sexpt)

		/* once the transfer is done, then deserialize and update returns. */
		retv := c.gensym()
		goegrs += fmt.Sprintf("\t%s := deserialize%s_arg_EgressReturn(%s)\n", retv, v.name, sexpt)
		for j, _ := range v.ret {
			goegrs += fmt.Sprintf("\t%s = %s.%s\n", v.ret[j].name, retv, v.ret[j].name)
		}
		/* we are done here */
		goegrs += "\treturn\n}\n\n"
		c.goegrs += goegrs
	}

	cxmain += stdcxmainfooter
	c.cxmain = cxmain
}
