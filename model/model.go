//code generated by CXDatum. DO NOT EDIT.

package model

import (
	"github.com/SkycoinProject/skycoin/src/cipher"
)

func makeInt(b []byte) int {
	return (int(b[0]) << 24) | (int(b[1]) << 16) | (int(b[2]) << 8) | int(b[3])
}

func breakInt(i int) []byte {
	b := make([]byte, 4)
	b[0] = byte((i & 0xFF000000) >> 24)
	b[1] = byte((i & 0xFF0000) >> 16)
	b[2] = byte((i & 0xFF00) >> 8)
	b[3] = byte(i & 0xFF)
	return b
}

type Tweet struct {
	owner cipher.Address
	obj   cipher.SHA256
	txt   string
	likes int
	retwt int
	tags  []cipher.Address
	hashs []string
	rplto cipher.SHA256
}

type Account struct {
	name      string
	cname     string
	id        cipher.Address
	bio       string
	pfp       string
	tweets    []cipher.SHA256
	likes     []cipher.SHA256
	retweets  []cipher.SHA256
	tags      []cipher.SHA256
	followers []cipher.Address
	following []cipher.Address
	followcnt int
	fllwngcnt int
}

type Hashtag struct {
	name   string
	tlikes int
	trtwts int
	tweets []cipher.SHA256
}

type getTweet_arg_EgressExpect struct {
	txid cipher.SHA256
}

type getTweet_arg_EgressReturn struct {
	txt Tweet
}

func serializeTweet(obj Tweet) []byte {
	var out []byte
	out = append(out, obj.owner.Bytes()...)
	out = append(out, obj.obj[:]...)
	out = append(out, []byte(obj.txt)...)
	out = append(out, breakInt(obj.likes)...)
	out = append(out, breakInt(obj.retwt)...)
	out = append(out, breakInt(len(obj.tags))...)
	for i := 0; i < len(obj.tags); i++ {
		out = append(out, obj.tags[i].Bytes()...)
	}
	out = append(out, breakInt(len(obj.hashs))...)
	for i := 0; i < len(obj.hashs); i++ {
		out = append(out, []byte(obj.hashs[i])...)
	}
	out = append(out, obj.rplto[:]...)
	return out
}

func serializeAccount(obj Account) []byte {
	var out []byte
	out = append(out, []byte(obj.name)...)
	out = append(out, []byte(obj.cname)...)
	out = append(out, obj.id.Bytes()...)
	out = append(out, []byte(obj.bio)...)
	out = append(out, []byte(obj.pfp)...)
	out = append(out, breakInt(len(obj.tweets))...)
	for i := 0; i < len(obj.tweets); i++ {
		out = append(out, obj.tweets[i][:]...)
	}
	out = append(out, breakInt(len(obj.likes))...)
	for i := 0; i < len(obj.likes); i++ {
		out = append(out, obj.likes[i][:]...)
	}
	out = append(out, breakInt(len(obj.retweets))...)
	for i := 0; i < len(obj.retweets); i++ {
		out = append(out, obj.retweets[i][:]...)
	}
	out = append(out, breakInt(len(obj.tags))...)
	for i := 0; i < len(obj.tags); i++ {
		out = append(out, obj.tags[i][:]...)
	}
	out = append(out, breakInt(len(obj.followers))...)
	for i := 0; i < len(obj.followers); i++ {
		out = append(out, obj.followers[i].Bytes()...)
	}
	out = append(out, breakInt(len(obj.following))...)
	for i := 0; i < len(obj.following); i++ {
		out = append(out, obj.following[i].Bytes()...)
	}
	out = append(out, breakInt(obj.followcnt)...)
	out = append(out, breakInt(obj.fllwngcnt)...)
	return out
}

func serializeHashtag(obj Hashtag) []byte {
	var out []byte
	out = append(out, []byte(obj.name)...)
	out = append(out, breakInt(obj.tlikes)...)
	out = append(out, breakInt(obj.trtwts)...)
	out = append(out, breakInt(len(obj.tweets))...)
	for i := 0; i < len(obj.tweets); i++ {
		out = append(out, obj.tweets[i][:]...)
	}
	return out
}

func serializegetTweet_arg_EgressExpect(obj getTweet_arg_EgressExpect) []byte {
	var out []byte
	out = append(out, obj.txid[:]...)
	return out
}

func serializegetTweet_arg_EgressReturn(obj getTweet_arg_EgressReturn) []byte {
	var out []byte
	out = serializeTweet(obj.txt)
	return out
}

func deserializeTweet(b []byte) Tweet {
	_cxdatum_tmp_33Tweet := Tweet{}
	slen := len(b)
	if slen == 0 {
		return _cxdatum_tmp_33Tweet
	}
	_cxdatum_tmp_33Tweet.owner, _ = cipher.AddressFromBytes(b[:25])
	b = b[25:]
	_cxdatum_tmp_33Tweet.obj, _ = cipher.SHA256FromBytes(b[:32])
	b = b[32:]
	slen = makeInt(b[:4])
	b = b[4:]
	_cxdatum_tmp_33Tweet.txt = string(b[:slen])
	b = b[slen:]
	_cxdatum_tmp_33Tweet.likes = makeInt(b[:4])
	b = b[4:]
	_cxdatum_tmp_33Tweet.retwt = makeInt(b[:4])
	b = b[4:]
	slen = makeInt(b[:4])
	b = b[4:]
	for i := 0; i < slen; i++ {
		tmp__, _ := cipher.AddressFromBytes(b[:25])
		_cxdatum_tmp_33Tweet.tags = append(_cxdatum_tmp_33Tweet.tags, tmp__)
		b = b[25:]
	}
	slen = makeInt(b[:4])
	b = b[4:]
	for i := 0; i < slen; i++ {
		tmp__ := makeInt(b[:4])
		_cxdatum_tmp_33Tweet.hashs = append(_cxdatum_tmp_33Tweet.hashs, string(b[:tmp__]))
		b = b[tmp__:]
	}
	_cxdatum_tmp_33Tweet.rplto, _ = cipher.SHA256FromBytes(b[:32])
	b = b[32:]
	return _cxdatum_tmp_33Tweet
}

func deserializeAccount(b []byte) Account {
	_cxdatum_tmp_86Account := Account{}
	slen := len(b)
	if slen == 0 {
		return _cxdatum_tmp_86Account
	}
	slen = makeInt(b[:4])
	b = b[4:]
	_cxdatum_tmp_86Account.name = string(b[:slen])
	b = b[slen:]
	slen = makeInt(b[:4])
	b = b[4:]
	_cxdatum_tmp_86Account.cname = string(b[:slen])
	b = b[slen:]
	_cxdatum_tmp_86Account.id, _ = cipher.AddressFromBytes(b[:25])
	b = b[25:]
	slen = makeInt(b[:4])
	b = b[4:]
	_cxdatum_tmp_86Account.bio = string(b[:slen])
	b = b[slen:]
	slen = makeInt(b[:4])
	b = b[4:]
	_cxdatum_tmp_86Account.pfp = string(b[:slen])
	b = b[slen:]
	slen = makeInt(b[:4])
	b = b[4:]
	for i := 0; i < slen; i++ {
		tmp__, _ := cipher.SHA256FromBytes(b[:32])
		_cxdatum_tmp_86Account.tweets = append(_cxdatum_tmp_86Account.tweets, tmp__)
		b = b[32:]
	}
	slen = makeInt(b[:4])
	b = b[4:]
	for i := 0; i < slen; i++ {
		tmp__, _ := cipher.SHA256FromBytes(b[:32])
		_cxdatum_tmp_86Account.likes = append(_cxdatum_tmp_86Account.likes, tmp__)
		b = b[32:]
	}
	slen = makeInt(b[:4])
	b = b[4:]
	for i := 0; i < slen; i++ {
		tmp__, _ := cipher.SHA256FromBytes(b[:32])
		_cxdatum_tmp_86Account.retweets = append(_cxdatum_tmp_86Account.retweets, tmp__)
		b = b[32:]
	}
	slen = makeInt(b[:4])
	b = b[4:]
	for i := 0; i < slen; i++ {
		tmp__, _ := cipher.SHA256FromBytes(b[:32])
		_cxdatum_tmp_86Account.tags = append(_cxdatum_tmp_86Account.tags, tmp__)
		b = b[32:]
	}
	slen = makeInt(b[:4])
	b = b[4:]
	for i := 0; i < slen; i++ {
		tmp__, _ := cipher.AddressFromBytes(b[:25])
		_cxdatum_tmp_86Account.followers = append(_cxdatum_tmp_86Account.followers, tmp__)
		b = b[25:]
	}
	slen = makeInt(b[:4])
	b = b[4:]
	for i := 0; i < slen; i++ {
		tmp__, _ := cipher.AddressFromBytes(b[:25])
		_cxdatum_tmp_86Account.following = append(_cxdatum_tmp_86Account.following, tmp__)
		b = b[25:]
	}
	_cxdatum_tmp_86Account.followcnt = makeInt(b[:4])
	b = b[4:]
	_cxdatum_tmp_86Account.fllwngcnt = makeInt(b[:4])
	b = b[4:]
	return _cxdatum_tmp_86Account
}

func deserializeHashtag(b []byte) Hashtag {
	_cxdatum_tmp_103Hashtag := Hashtag{}
	slen := len(b)
	if slen == 0 {
		return _cxdatum_tmp_103Hashtag
	}
	slen = makeInt(b[:4])
	b = b[4:]
	_cxdatum_tmp_103Hashtag.name = string(b[:slen])
	b = b[slen:]
	_cxdatum_tmp_103Hashtag.tlikes = makeInt(b[:4])
	b = b[4:]
	_cxdatum_tmp_103Hashtag.trtwts = makeInt(b[:4])
	b = b[4:]
	slen = makeInt(b[:4])
	b = b[4:]
	for i := 0; i < slen; i++ {
		tmp__, _ := cipher.SHA256FromBytes(b[:32])
		_cxdatum_tmp_103Hashtag.tweets = append(_cxdatum_tmp_103Hashtag.tweets, tmp__)
		b = b[32:]
	}
	return _cxdatum_tmp_103Hashtag
}

func deserializegetTweet_arg_EgressExpect(b []byte) getTweet_arg_EgressExpect {
	_cxdatum_tmp_129getTweet_arg_EgressExpect := getTweet_arg_EgressExpect{}
	slen := len(b)
	if slen == 0 {
		return _cxdatum_tmp_129getTweet_arg_EgressExpect
	}
	_cxdatum_tmp_129getTweet_arg_EgressExpect.txid, _ = cipher.SHA256FromBytes(b[:32])
	b = b[32:]
	return _cxdatum_tmp_129getTweet_arg_EgressExpect
}

func deserializegetTweet_arg_EgressReturn(b []byte) getTweet_arg_EgressReturn {
	_cxdatum_tmp_132getTweet_arg_EgressReturn := getTweet_arg_EgressReturn{}
	slen := len(b)
	if slen == 0 {
		return _cxdatum_tmp_132getTweet_arg_EgressReturn
	}
	_cxdatum_tmp_132getTweet_arg_EgressReturn.txt = deserializeTweet(b)
	return _cxdatum_tmp_132getTweet_arg_EgressReturn
}
